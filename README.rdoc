== HasScope

Has scope allows you to easily create controller filters based on your resources named scopes.
Imagine the following model called graduations:

  class Graduation < ActiveRecord::Base
    named_scope :featured, :conditions => { :featured => true }
    named_scope :by_degree, proc {|degree| { :conditions => { :degree => degree } } }
  end

You can use those named scopes as filters by declaring them on your controller:

  class GraduationsController < ApplicationController
    has_scope :featured, :type => :boolean
    has_scope :by_degree
  end

Now, if you want to apply them to an specific resource, you just need to call <tt>apply_scopes</tt>:

  class GraduationsController < ApplicationController
    has_scope :featured, :type => :boolean
    has_scope :by_degree
    has_scope :by_period, :using => [:started_at, :ended_at]

    def index
      @graduations = apply_scopes(Graduation).all
    end
  end

Then for each request:

  /graduations
  #=> acts like a normal request

  /graduations?featured=true
  #=> calls the named scope and bring featured graduations

  /graduations?featured=true&by_degree=phd
  #=> brings featured graduations with phd degree

  /graduations?params[by_period][started_at]=20100701&params[by_period][ended_at]=20101013
  #=> brings graduations in the given period

You can retrieve all the scopes applied in one action with <tt>current_scopes</tt> method.
In the last case, it would return: { :featured => true, :by_degree => "phd" }.

== Installation

Rails3 way only:

    gem 'has_scope', :git => 'git://github.com/rymai/has_scope.git'

== <tt>has_scope</tt> options

<tt>has_scope</tt> supports several options:

* <tt>:type</tt> - Checks the type of the parameter sent. If set to :boolean it just calls the named scope, without any argument. By default, it does not allow hashes or arrays to be given, except if type :hash or :array are set.

* <tt>:only</tt> - In which actions the scope is applied.

* <tt>:except</tt> - In which actions the scope is not applied.

* <tt>:as</tt> - The key in the params hash expected to find the scope. Defaults to the scope name.

* <tt>:using</tt> - The subkeys to be used as args when type is a hash.

* <tt>:if</tt> - Specifies a method, proc or string to call to determine if the scope should apply.

* <tt>:unless</tt> - Specifies a method, proc or string to call to determine if the scope should NOT apply.

* <tt>:default</tt> - Declares a scope as a default and give it a default value. Default scopes are only called if no scope is given explicitly and no global default scope is given in <tt>apply_scopes</tt>.

* <tt>:allow_blank</tt> - Blank values are not sent to scopes by default. Set to true to overwrite.

== Global default scope

You can also set a global default scope when calling <tt>apply_scopes</tt>, activated when no scope is explicitly given in the params.
This global default scope will override every default scope declared with the <tt>:default</tt> options of <tt>has_scope</tt> (see below).

Just call apply_scopes like this:

  def index
    @flowers = apply_scopes(Flower, params, :default => { :by_color => 'red' }).all
  end

Then for each request:

  /flowers
  #=> no explicit scope given, calls the by_color('red') default scope

  /flowers?by_size=tiny
  #=> explicit scope given, calls only by_size('tiny') scope

  /flowers?by_color=blue
  #=> as a normal explicit given scope, calls only the scope by_color('blue')

<u>Note:</u> You have to give the <tt>apply_scopes</tt> an explicit second parameter (usually <tt>params</tt>) in order to have the :default scope to work well.

== Priority order of default scopes

The priority order for default scopes is as follow:
  
  1. Global default scopes: called if no explicit scopes given
  2. Individual default scopes: called if no explicit scopes given and no global default scopes given

== Block usage

has_scope also accepts a block. The controller, current scope and value are yielded
to the block so the user can apply the scope on its own. This is useful in case we
need to manipulate the given value:

  has_scope :category do |controller, scope, value|
    value != "all" ? scope.by_category(value) : scope
  end

When used with booleans, it just receives two arguments and is just invoked if true is given:

  has_scope :not_voted_by_me, :type => :boolean do |controller, scope|
    scope.not_voted_by(controller.current_user.id) 
  end

== Contributions

RÃ©my Coutable - http://github.com/rymai

* Global default scopes.

* Changed <tt>has_scope</tt>'s <tt>:default</tt> option behavior, to be has a real "default" behavior and not an "always" behavior.

== Bugs and Feedback

If you discover any bugs or want to drop a line, feel free to create an issue on GitHub.

http://github.com/rymai/has_scope/issues

MIT License. Copyright 2009 Plataforma Tecnologia. http://blog.plataformatec.com.br
